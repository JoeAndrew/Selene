This file is not a real documentation for Selene (that still has to come) but only a list of thinks I have to take in account when I'll write this famous documentation.

Compilation options :
=====================

Following directives have to be added to enable some features.

DirectFB :
----------
-DUSE_DIRECTFB
`directfb-config --cflags` `directfb-config --libs`

MQTT (paho)
-----------
-DUSE_MQTT
-lpaho-mqtt3c

(-lpthread not required)


Runtime options
===============
Following DirectFB may be useful :

--dfb:quiet : Remove DirectFB verbosity

--dfb:no-vt : Make it working for a non-root user from ssh 
(the user has to be belong to 'video' group)

General
=======

SELENE_VERSION - majeur.minorsub (i.e. 0.0112 => major :0, minor : 1, subversion : 12)

Sleep() : make the process sleeping. The argument, in second, may be a float


DirectFB
========
createfont( fontname, { size=int } )

font:SetEncoding() can take a string or a id (int) as argument.
In case of string it is converted to id.

createsurface()
	caps : DFBSurfaceCapabilities
	width
	height
	size={w,h}

Layer.CreateWindow()
	caps : DFBWindowCapabilities
	width
	height
	size={w,h}
	x
	y
	pos={x,y}

SelMQTT.connect()
	keepAliveInterval : int (seconds)
	cleansession : bool
	reliable : bool
	username
	password
	clientID : string 
	persistence : string - if set, indicate the persistence directory
						- if not set, no persistence (data only stored in memory)


MQTT
====

Only textual topic and messages are correctly handled. Result is not defined for non-textual object

func : function called at message arrival. Typically, used to set a SelShared function. Note : callbacks function run on a separate context and, consequently, can't share global variables with the main application or it's loaded libraries.
<- Do we have to launch a trigger function ?

trigger : function running in the main application context mostly used to updated the GUI because the corresponding SelShared has changed.

trigger_once : true if the trigger has to be launched once (default)
			false if the trigger will be launched as many as arrived messages

Timer
=====

Timer.create()
	when : initial timer value
	interval : repeat at interval seconds (0 = one shot)
	clockid : clock to use (ClockModeConst()'s CLOCK_REALTIME or CLOCK_MONOTONIC)
	ifunc : function to be called "immediately" when the timer expires (immediately, means as soon as possible and when WaitFor() is called)
	task : function to add in the todo list
	once : if true, this function is put only once

TODO :
======

DEV NOTE :
==========
timerfd : pour les timers
eventfd : sorte de compteur. Si 0, bloque jusqu'a ce que qqchose arrive

poll() - http://www.ulduzsoft.com/2014/01/select-poll-epoll-practical-difference-for-system-architects/

=>
Utiliser SharedStuffs.tlfd et le fd des timer et faire un poll() pour la boucle générale.
